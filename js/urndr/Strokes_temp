// ALMOST DEPRECATED BUT IMPORTANT CODE HISTORY

delete_strokes_out_of_boundary : function() {
    var module = new URNDR.Module("Remove invisible points from strokes",URNDR.STROKE_MODULE,999,false);
    module.setFunction(function(STROKES) {
        var data = STROKES.data
        for (var stroke_n = 0 ; stroke_n < STROKES.getStrokesCount() ; stroke_n ++) {
            if ( STROKES.getStrokeLength(stroke_n) === 0) break;
            var this_stroke = STROKES.getStroke(stroke_n), condition = true;
            for ( var i = 0 ; i < STROKES.getStrokeLength(stroke_n) ; i++ ) {
                condition = condition && (this_stroke.X[i] < 0 || this_stroke.X[i] > CANVAS.width || this_stroke.Y[i] < 0 || this_stroke.Y[i] > CANVAS.height);
            }
            if (condition) { STROKES.deleteStroke(stroke_n); }
        }
    })
    return module
},

blow_strokes : function() {
    var module = new URNDR.Module("Blow Strokes",URNDR.STROKE_MODULE,71,false);
    module.setFunction(function(STROKES) {
        var data = STROKES.data;
        var max = data.X.length;
        for ( var i = 0 ; i < max ; i++ ) {
            blow(data.X[i]);
            blow(data.Y[i]);
        }
        function blow(arr,center,force) {
            var l = arr.length;
            if (!center) {
                center = 0;
                for ( var i = 0 ; i < l ; i ++ ) { center += arr[i]; }
                center /= l;
            }
            if (!force) {force = 0.01;}
            for ( i = 0 ; i < l ; i ++ ) {
                arr[i] += (arr[i] - center) * force
            }
        }
    })
    return module
},




this.prototype.optimizeStroke = function( stroke_n ) {
        var stroke, stroke_length, deleted_point_count;

        deleted_point_count = 0;

        // Goals : 
        // Remove strokes points with size / alpha zero
        stroke = this.getStroke(stroke_n);
        stroke_length = this.getStrokeLength(stroke_n);
        for ( var point_n = 0 ; point_n < stroke_length ; point_n ++ ) {

            if (stroke.S[point_n] === 0 || stroke.A[point_n] === 0) {
                this.deletePointInStroke(stroke_n, point_n);
                deleted_point_count += 1;
            }

        }

        //
        // Speparate strokes into not mapped ones and mapped ones
        function checkBarycentricCoordinate( stroke , point_n ) {
            return stroke.Barycentric[ point_n ] ? true : false
        }

        var flag = {new_lines:0,state:null,cutpoints:[]}
        stroke = this.getStroke(stroke_n);
        stroke_length = this.getStrokeLength(stroke_n);
        flag.state = checkBarycentricCoordinate( stroke , 0 )
        for ( var point_n = 1 ; point_n < stroke_length ; point_n ++ ) {
            var b = checkBarycentricCoordinate(stroke, point_n);
            if (b !== flag.state) {
                console.log(point_n,b?"3D":"2D")
                flag.cutpoints.push(point_n)
                flag.state = b
                flag.new_lines ++;
            }
        }
        console.log("// CUT TIME //")
        var cut = 0;
        var newStrokes = [];
        var bufferStroke;
        while (cut < flag.cutpoints.length) {
            console.log("from",0,"to",flag.cutpoints[cut])
            newStrokes.push()
            cut += 1;
        }
        console.log("")

        //
        // check if the stroke's length is zero, if so delete it
        stroke_length = this.getStrokeLength(stroke_n);
    }
    this.getStrokeCenter = function(stroke_n) {
        var stroke = this.getStroke(stroke_n),
            len = this.getStrokeLength(stroke_n),
            sum = [0,0,0];
        for( var p = 0 ; p < len ; p ++ ) { sum[0] += stroke.X[p]; sum[1] += stroke.Y[p]; sum[2] += stroke.Z[p]; }
        sum[0] /= len; sum[1] /= len; sum[2] /= len;
        return sum;
    }